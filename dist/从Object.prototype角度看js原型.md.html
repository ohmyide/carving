<!DOCTYPE html>
<html>
<head>
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta charset="utf-8">
   <title>Documents</title>
   <meta name="description" content="">
   <meta name="author" content="">
   <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1">
   <link rel="stylesheet" href="./assets/test.css">
   <link rel="shortcut icon" href="">
   <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11bc17e004cc00e2ed1d71777294097e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>

<body dir="ltr">
    <div class="wrap">
        <header>
            <div class="header-wrap">
                <a class="site-title header-item" href="./">
                    Oh My IDE
                    <b class="command_prompt"></b>
                    <b class="blinking_cursor">_</b>
                </a>
                <a class="header-item" href="./about.html">README</a>
            </div>
        </header>
        <main class="container">

<p>js原型是该语言的核心本质，可以说，没理解js原型就没学会js，js中的各个对象通过原型链的层层引用实现了各种方法的继承。其中关系错综复杂，我们先从这些原型链的『根』开始：</p>
<!-- more -->
<h2 id="objectprototype">Object.prototype <a class="markdownIt-Anchor" href="#objectprototype">#</a></h2>
<p>为什么说<code>Object.prototype</code>是原型链的根？我们先把它打印出来开始：<br>
<img src="http://7xprui.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-08%20%E4%B8%8B%E5%8D%887.41.38.png" alt="Object.prototype"><br>
可见，其原型上有几个熟悉的方法：</p>
<ul>
<li>hasOwnProperty</li>
<li>isPrototypeOf</li>
<li>toLocaleString</li>
<li>toString</li>
<li>valueOf</li>
</ul>
<p>这里方法的功能不是本文重点，这里不做介绍。只要记着Object的原型上有这几个方法就好,且<strong>留意hasOwnProperty函数，具体原因后续说明</strong>此时我们回忆下js的引用类型有以下几种：</p>
<ul>
<li>Object</li>
<li>Function</li>
<li>Number</li>
<li>RegExp</li>
<li>Date</li>
<li>Boolean</li>
</ul>
<p>我们知道这些引用型的实例就是我们常用的对象，函数，数值，正则，日期和布尔型数据，也就是说：</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> arr = [];
<span class="hljs-comment">// 相当于</span>
<span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();

---

<span class="hljs-keyword">var</span> o = {};
<span class="hljs-comment">// 相当于</span>
<span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>{};
<span class="hljs-comment">// 相当于</span>
<span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>();

<span class="hljs-keyword">var</span> d = <span class="hljs-number">2</span>;
<span class="hljs-comment">// 相当于</span>
<span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">2</span>);
</code></pre>
<p>首先，我们应该都知道new出的实例会继承父对象中prototype中的方法，比如我们打印Array.prototype：<br>
<img src="http://7xprui.com1.z0.glb.clouddn.com/QQ20170308-194513.png" alt="Array.prototype"><br>
我们看到，数组常用的方法都能在里面找到，所以new出来的数组实例arr自然拥有上述方法。但有个<strong>奇怪的函数hasOwnProperty</strong>：</p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.dir(arr.hasOwnProperty)
</code></pre>
<p><img src="http://7xprui.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-08%20%E4%B8%8B%E5%8D%887.41.59.png" alt="arr.hasOwnProperty"><br>
Array的原型中，也就是Array.prototype中并没有hasOwnProperty。</p>
<h2 id="arrhasownproperty从哪里来">arr.hasOwnProperty从哪里来？ <a class="markdownIt-Anchor" href="#arrhasownproperty从哪里来">#</a></h2>
<p>答案就是从js的『根』中来，也就是来自Object.prototype。</p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(arr.hasOwnProperty === <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty) <span class="hljs-comment">//true</span>
</code></pre>
<p>下面这句特别重要：<br>
实例arr的属性方法来自实例化它的Array的原型（Array.prototype）,那Array.prototype中的方法又来自哪里？答案是：一部分是js根据Array类型特意内置的，比如说sort方法，其余类型就没有，还有一部分就是来自根：<code>Object.prototype</code>,通过神秘的<code>__proto__</code>来实现引用：</p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(arr.hasOwnProperty === <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty) <span class="hljs-comment">//true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype.hasOwnProperty === <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty) <span class="hljs-comment">//true</span>
</code></pre>
<p>而<code>__proto__</code>指向实例化它的对象的原型，也就是：实例化它的对象的prototype：</p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(arr.__proto__ === <span class="hljs-built_in">Array</span>.prototype) <span class="hljs-comment">//true</span>
</code></pre>
<p>那Array.prototype对象（原型也是对象）是谁实例化的呢？上面已经揭晓，既然Array.prototype中引用了Object.prototype中的方法，自然：<br>
console.log(Array.prototype.<strong>proto</strong> === Object.prototype) //true<br>
到这里我们几乎可以这么理解：arr的根是Array.prototype，而Array.prototype的根，也就是js的根：<code>Object.prototype</code>,<code>Object.prototype</code>上的方法自然能被层层下属使用，hasOwnProperty就是最好的说明。<br>
除Array外，其余也是如此：</p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span>.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">//true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">//true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">//true</span>
<span class="hljs-comment">// .......</span>
</code></pre>
<blockquote>
<p>为什么Object.prototype中有这么多方法，本文只拿hasOwnProperty来做说明，答案是因为：其余方法如toString，valueOf会根据数据类型情况而被重写，比如Date型和Boolean型的toString和valueOf就是被重写改造后的，并没用使用根中自带的，这里就不举例了。</p>
</blockquote>
<h2 id="验证一下">验证一下 <a class="markdownIt-Anchor" href="#验证一下">#</a></h2>
<p>既然Object.prototype是根，且里面的方法可以层层被继承使用，那么这里就验证一下：<br>
我们在Object.prototype上新增一个方法test：</p>
<pre class="hljs"><code><span class="hljs-built_in">Object</span>.prototype.test = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是来自js根中的方法！&quot;</span>)
}

<span class="hljs-comment">//创建不同数据类型的实例:</span>
<span class="hljs-keyword">var</span> arr = [];
<span class="hljs-keyword">var</span> b = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">var</span> d = <span class="hljs-built_in">Date</span>();
<span class="hljs-comment">// ...</span>

arr.test(); <span class="hljs-comment">//这是来自js根的测试方法！</span>
b.test(); <span class="hljs-comment">//这是来自js根的测试方法！</span>
d.test(); <span class="hljs-comment">//这是来自js根的测试方法！</span>

<span class="hljs-comment">// ...毫无疑问所有的实例都拥有了test方法</span>
</code></pre>
<p>上述大范围从根上扩充只是测试，一般情况下我们针对某一类型进行扩充足矣，比如js的trim方法只去两头空格，不包括中间空格，那么我们只需针对String类型在其原型上创建去全部空格方法allTrim即可：</p>
<pre class="hljs"><code><span class="hljs-built_in">String</span>.prototype.allTrim = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.replace(<span class="hljs-regexp">/\s+/g</span>,<span class="hljs-string">&quot;&quot;</span>);
}
<span class="hljs-string">&quot;   aa  bb  cc   &quot;</span>.allTrim(); <span class="hljs-comment">//aabbcc</span>
</code></pre>
<p>这样所有的字符串实例都有了allTrim方法，理解了js的原型，则理解了js的继承机制。</p>
<h2 id="一切皆空">一切皆空 <a class="markdownIt-Anchor" href="#一切皆空">#</a></h2>
<p>既然Array、Function、Number的原型对象都通过<code>__proto__</code>引用自根<code>Object.prototype</code>，那么<code>Object.prototype</code>也是一个原型对象，它的根又来自哪里呢？答案是<code>null</code>。</p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.__proto__) <span class="hljs-comment">// null</span>
</code></pre>
<p>null 才是js原型链的终结。</p>
        <main>
        <div class="progress-indicator">我是页脚</div>
    <div class="wrap">
</body>
</html>